# Ribbon Solver - Group Theory Edition

A group-theoretic approach to automated mathematical discovery, reimagining `ribbon_solver3` through the lens of abstract algebra.

## Core Idea

The 6D truth space from the [Truth Space Expedition](../../../truth_space_expedition/PAPER.md) forms a **Lie group** where:

| Group Concept | Truth Space Interpretation |
|---------------|---------------------------|
| **Group Elements** | Points in 6D anchor space |
| **Group Operation** | Composition of transformations |
| **Identity** | Origin (all anchors = 0) |
| **Inverses** | Inverse functions (arctan ↔ tan) |
| **Subgroups** | Mathematical categories |
| **Symmetries** | Mathematical identities |

## The 6 Anchors as Lie Algebra Generators

```
Generator   Symbol   Value        Mathematical Meaning
─────────────────────────────────────────────────────────
identity    I        0.0          Null transformation, x → x
stability   S        1.0          Fixed points, normalization
inverse     V        1/√2 ≈ 0.707 Inverse compositions
unity       U        1.0          Pythagorean identities
pattern     P        log₂3 ≈ 1.585 Sierpinski, recursion
growth      G        φ ≈ 1.618    Golden ratio, self-similarity
```

## Key Insight: Symmetry IS Truth

A mathematical identity like `sin²(x) + cos²(x) = 1` is a **symmetry** of truth space—a transformation that leaves the truth invariant.

Finding identities = Finding fixed points of group actions.

## Quick Start

```python
from ribbon_solver_group_theory import TruthGroup, GroupDiscovery

# Create the truth group
group = TruthGroup()

# Create group elements from expressions
g = group.element("sin²(x) + cos²(x)")
h = group.element("1")

# Check if they're equivalent (same truth)
if group.are_equivalent(g, h):
    print("Identity found!")

# Find symmetries
discovery = GroupDiscovery()
result = discovery.find_symmetries("arctan(tan(x))")
```

## Mapping from ribbon_solver3

| ribbon_solver3 | Group Theory Edition | Group Concept |
|----------------|---------------------|---------------|
| `optimize_file()` | `find_symmetries()` | Find invariants |
| `find_formula()` | `find_orbit()` | Explore group action |
| `find_identities()` | `find_fixed_points()` | Find identity elements |
| `analyze()` | `classify()` | Determine subgroup |

## CLI Usage

```bash
# Find symmetries of an expression
python -m ribbon_solver_group_theory --symmetries "sin²(x) + cos²(x)"

# Find orbit of an expression
python -m ribbon_solver_group_theory --orbit "exp(x)" --depth 3

# Optimize via conjugation
python -m ribbon_solver_group_theory --optimize "arctan(tan(x))"

# Find a formula for π
python -m ribbon_solver_group_theory --formula pi --base 4096
```

## Group Operations

### Composition (⊕)
```python
# g₁ ⊕ g₂ = apply g₂ first, then g₁
composed = g1 @ g2  # Uses @ operator
```

### Inverse
```python
# g⁻¹ such that g ⊕ g⁻¹ = identity
inv = g.inverse()
```

### Conjugation
```python
# h ⊕ g ⊕ h⁻¹ (reveals equivalent truths)
conjugated = g.conjugate(h)
```

### Commutator (Lie Bracket)
```python
# [g, h] = g ⊕ h ⊕ g⁻¹ ⊕ h⁻¹
bracket = g.commutator(h)
```

## Subgroups

The truth group has natural subgroups corresponding to mathematical categories:

```python
group = TruthGroup()

# Trigonometric subgroup: Generated by {unity, pattern}
trig = group.subgroups['trigonometric']

# Exponential subgroup: Generated by {inverse, growth}
exp = group.subgroups['exponential']

# Algebraic subgroup: Generated by {identity, stability}
alg = group.subgroups['algebraic']
```

## Philosophy

- **SYMMETRY IS TRUTH**: Identities are fixed points under group action
- **PROOF IS PATH**: Geodesics through the group manifold
- **ERROR IS SIGNAL**: Deviations reveal hidden symmetries

## Connection to Truth Space Papers

This implementation formalizes the geometric structure discovered in the Truth Space Expedition:

1. **Fractal Structure** → Lie algebra structure constants
2. **Sierpinski-like geometry** → Pattern generator
3. **Schwarzschild funnel** → Metric on group manifold
4. **Proof as navigation** → Geodesics in group

## Architecture

```
ribbon_solver_group_theory/
├── __init__.py          # Package interface
├── __main__.py          # CLI entry point
├── discover.py          # High-level discovery interface
├── demo.py              # Demonstration script
├── README.md            # This file
│
├── core/                # STRUCTURE - The mathematical foundation
│   ├── __init__.py
│   └── group_structure.py   # TruthGroup, GroupElement, AnchorVector
│
└── processors/          # ACTION - Modules that use the core
    ├── __init__.py
    ├── base.py              # BaseProcessor abstract class
    ├── code_optimizer.py    # Find code optimizations
    ├── identity_miner.py    # Discover mathematical identities
    ├── formula_discovery.py # Find formulas for constants
    ├── error_analyzer.py    # Use error-as-signal
    └── symmetry_finder.py   # Find symmetries of expressions
```

## Design Philosophy

**Core is STRUCTURE, Processors are ACTION.**

- **Core** defines WHERE truths live (the group manifold)
- **Processors** find WHAT to do with them (optimize, discover, analyze)

This separation allows:
1. New processors without changing core
2. Different processors for different use cases
3. Composable pipelines
4. Easy testing and debugging

## Processors

### CodeOptimizer
Scans code for optimization opportunities using group-theoretic symmetry detection.

```python
from ribbon_solver_group_theory import CodeOptimizer, TruthGroup

group = TruthGroup()
optimizer = CodeOptimizer(group)
result = optimizer.optimize_file("path/to/code.py")
result = optimizer.optimize_expressions(["arctan(tan(x))", "sin²(x) + cos²(x)"])
```

### IdentityMiner
Discovers new mathematical identities using group-theoretic search.

```python
from ribbon_solver_group_theory import IdentityMiner, TruthGroup

group = TruthGroup()
miner = IdentityMiner(group)
result = miner.mine_machin_like(max_terms=3)  # Arctan identities for π
result = miner.mine_pythagorean()  # Pythagorean-type identities
```

### FormulaDiscovery
Finds formulas for mathematical constants using error-as-signal.

```python
from ribbon_solver_group_theory import FormulaDiscovery, TruthGroup

group = TruthGroup()
discovery = FormulaDiscovery(group)
result = discovery.discover_bbp(base=4096, target='pi')
```

### ErrorAnalyzer
Analyzes error structure to find mathematical patterns (φ-corrections, etc.).

```python
from ribbon_solver_group_theory import ErrorAnalyzer, TruthGroup

group = TruthGroup()
analyzer = ErrorAnalyzer(group)
result = analyzer.analyze_coefficients([256.02, -32.05, 4.01])
```

### SymmetryFinder
Finds symmetries (fixed points) of mathematical expressions.

```python
from ribbon_solver_group_theory import SymmetryFinder, TruthGroup

group = TruthGroup()
finder = SymmetryFinder(group)
result = finder.find_symmetries("sin²(x) + cos²(x)")
```

## AI Agents

The `agents/` module provides AI-driven automation for truth space operations.

### Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TruthSpaceOrchestrator                           │
│         (Coordinates all agents, manages workflow)                  │
└─────────────────────────────────────────────────────────────────────┘
                                │
        ┌───────────────────────┼───────────────────────────┐
        │                       │                           │
        ▼                       ▼                           ▼
    ┌─────────────┐     ┌─────────────┐         ┌─────────────────┐
    │ TaskRouter  │     │ Formula     │         │ RibbonSpeech    │
    │             │     │ Parser      │         │ Translator      │
    │ Classifies  │     │             │         │                 │
    │ user intent │     │ NL → Math   │         │ Math ↔ Speech   │
    └─────────────┘     └─────────────┘         └─────────────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │ TruthSpaceNavigator │
                    │                     │
                    │ Explores group      │
                    │ structure           │
                    └─────────────────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │   JSON Report       │
                    │   (Findings)        │
                    └─────────────────────┘
```

### TruthSpaceOrchestrator

The main entry point for AI-driven truth space operations.

```python
from ribbon_solver_group_theory import TruthSpaceOrchestrator

orchestrator = TruthSpaceOrchestrator()

# Process a natural language query
result = orchestrator.process("find identities of phi times phi")

# Print human-readable report
result.print_report()

# Get JSON for MCP/API integration
json_output = result.to_json()
```

### Task Types

The system automatically routes queries to appropriate handlers:

- **EXPLORE**: Navigate truth space, find related truths
- **SIMPLIFY**: Find simpler forms of expressions
- **DISCOVER**: Find new identities or formulas
- **VERIFY**: Check if an identity is valid
- **TRANSLATE**: Convert between representations
- **ANALYZE**: Analyze properties of an expression

### Ribbon Speech

Ribbon Speech is a semantic language that describes mathematical expressions
in terms of their conceptual meaning, grounded in the 6 anchors:

```python
from ribbon_solver_group_theory import RibbonSpeechTranslator

translator = RibbonSpeechTranslator()
result = translator.process("phi * phi")
print(result.data['speech'])
# → "growth multiplied by growth, yielding harmony"
```

### Example Output

```
======================================================================
TRUTH SPACE ANALYSIS REPORT
======================================================================

Query: find identities of phi times phi
Task Type: EXPLORE
Status: ✓ Success

Parsed Formula: φ * φ
Ribbon Speech: growth multiplied by growth, yielding harmony

----------------------------------------------------------------------
FINDINGS
----------------------------------------------------------------------

1. Starting Position
   expression: φ * φ
   category: exponential
   dominant_anchor: GROWTH

2. Related Truth
   expression: phi + 1
   operation: simplification
   reason: φ² = φ + 1 (golden ratio identity)

----------------------------------------------------------------------
Total time: 15.5ms
======================================================================
```

## Visualizations

The `visualizations/` module provides tools to visualize navigation paths through
the 6D truth space hyperbigasket.

### Projection Hierarchy

The truth space has perfect self-similarity, allowing projection to any dimension:

```
6D Hyperbigasket (full truth space)
     ↓ project out one dimension
5D Hyperbigasket slice
     ↓
4D Tetrix (4-simplex Sierpiński)
     ↓
3D Sierpiński Pyramid ← Default view
     ↓
2D Sierpiński Triangle
     ↓
1D Cantor-like Line
```

### TruthSpaceVisualizer

```python
from ribbon_solver_group_theory import TruthSpaceVisualizer, ProjectionMode

viz = TruthSpaceVisualizer()

# Add navigation result
viz.plot_path(navigation_result, "φ × φ exploration")

# Add specific points
viz.add_point({'IDENTITY': 0.1, 'GROWTH': 0.6, ...}, "Start", "#ff6600")

# Choose projection mode
viz.set_mode(ProjectionMode.PYRAMID_3D)  # 3D Sierpiński pyramid
viz.set_mode(ProjectionMode.TRIANGLE_2D)  # 2D Sierpiński triangle
viz.set_mode(ProjectionMode.LINE_1D)      # 1D Cantor projection
viz.set_mode(ProjectionMode.FULL_6D)      # 6D parallel coordinates

# Render and show
viz.render()
viz.show()

# Or show all views at once
viz.multi_view()
viz.show()
```

### PathAnimator

Animate paths with camera rotation:

```python
from ribbon_solver_group_theory import PathAnimator, AnimationConfig

config = AnimationConfig(
    fps=30,
    rotate_camera=True,
    rotation_speed=2.0,
)

animator = PathAnimator(config)
animator.add_navigation_result(nav_result, "φ² exploration")
animator.animate_3d()
animator.show()

# Or save to file
animator.animate_3d(save_path="truth_space.gif")
```

### Multi-View Animation

```python
animator.animate_multi_view(save_path="multi_view.gif")
```

This creates a synchronized animation showing:
- 3D Sierpiński pyramid (with rotation)
- 2D Sierpiński triangle
- 6D parallel coordinates
- 1D Cantor projection

### Camera Views

```python
from ribbon_solver_group_theory import CameraView

viz.set_camera(CameraView.ISOMETRIC)  # Standard isometric
viz.set_camera(CameraView.GOLDEN)     # Golden angle view
viz.set_camera(CameraView.TOP)        # Top-down
viz.set_camera(CameraView.CUSTOM, elev=45, azim=60)  # Custom angles
```

## Example: Finding Identities

```python
from ribbon_solver_group_theory import GroupDiscovery

discovery = GroupDiscovery()

# Analyze an expression
result = discovery.analyze("sin²(x) + cos²(x)")
print(result)
# {
#   'expression': 'sin²(x) + cos²(x)',
#   'category': 'trigonometric',
#   'dominant_anchor': 'unity',
#   'optimizations': [{'simplified': '1', 'verified': True}]
# }

# Find all symmetries
result = discovery.find_symmetries("exp(log(x))")
# Found: exp(log(x)) = x (inverse composition)
```

## Mathematical Foundation

The 6 anchors form a basis for a 6-dimensional Lie algebra with structure constants:

```
[Xᵢ, Xⱼ] = Σₖ cᵢⱼₖ Xₖ

Key relations:
[inverse, pattern] → identity    (simplification)
[growth, pattern] → growth       (self-similarity)
[inverse, growth] → stability    (φ⁻¹ = φ - 1)
```

The group operation uses the Baker-Campbell-Hausdorff formula:
```
exp(X) · exp(Y) = exp(X + Y + ½[X,Y] + ...)
```

## Author

Holographer's Workbench  
December 2025
