"""
Group Structure - The Mathematical Foundation
==============================================

Defines the group-theoretic structure of truth space.

The 6D truth space forms a Lie group G with:
- Elements: 6-dimensional anchor vectors
- Operation: Composition (⊕) representing transformation chaining
- Identity: e = (0, 0, 0, 0, 0, 0)
- Inverse: Each element g has inverse g⁻¹ such that g ⊕ g⁻¹ = e

The 6 Anchors as Lie Algebra Generators:
    1. identity (I): Generator of null transformations
    2. stability (S): Generator of fixed-point transformations  
    3. inverse (V): Generator of inverse compositions
    4. unity (U): Generator of Pythagorean-type identities
    5. pattern (P): Generator of recursive/fractal structures
    6. growth (G): Generator of self-similar growth

Key Group Properties:
    - Non-abelian: g₁ ⊕ g₂ ≠ g₂ ⊕ g₁ in general
    - Connected: Any two elements can be joined by a path
    - Metric: d(g₁, g₂) = length of geodesic = "proof distance"

Subgroups:
    - Trigonometric: Generated by {U, P}
    - Exponential: Generated by {V, G}
    - Algebraic: Generated by {I, S}
"""

import numpy as np
from typing import List, Optional, Tuple, Dict, Callable
from dataclasses import dataclass, field
from enum import Enum
import math


# =============================================================================
# FUNDAMENTAL CONSTANTS (Anchor Values)
# =============================================================================

class Anchor(Enum):
    """The 6 fundamental anchors of truth space."""
    IDENTITY = 0    # I: Origin, null transformation
    STABILITY = 1   # S: Unit distance, fixed points
    INVERSE = 2     # V: Inverse operations (1/√2 ≈ 0.707)
    UNITY = 3       # U: Pythagorean unity
    PATTERN = 4     # P: Sierpinski dimension (log₂3 ≈ 1.585)
    GROWTH = 5      # G: Golden ratio (φ ≈ 1.618)


# Anchor characteristic values
ANCHOR_VALUES = {
    Anchor.IDENTITY: 0.0,
    Anchor.STABILITY: 1.0,
    Anchor.INVERSE: 1.0 / math.sqrt(2),  # ≈ 0.707
    Anchor.UNITY: 1.0,
    Anchor.PATTERN: math.log(3) / math.log(2),  # ≈ 1.585
    Anchor.GROWTH: (1 + math.sqrt(5)) / 2,  # φ ≈ 1.618
}

# Anchor names for display
ANCHOR_NAMES = ['identity', 'stability', 'inverse', 'unity', 'pattern', 'growth']


# =============================================================================
# ANCHOR VECTOR (Point in Truth Space)
# =============================================================================

@dataclass
class AnchorVector:
    """
    A point in 6D truth space, represented as anchor weights.
    
    This is the fundamental representation of a mathematical expression's
    "conceptual location" in truth space.
    """
    weights: np.ndarray = field(default_factory=lambda: np.zeros(6))
    
    def __post_init__(self):
        if isinstance(self.weights, list):
            self.weights = np.array(self.weights, dtype=float)
        self.weights = np.asarray(self.weights, dtype=float)
        if len(self.weights) != 6:
            raise ValueError(f"AnchorVector must have 6 components, got {len(self.weights)}")
    
    @classmethod
    def from_dict(cls, d: Dict[str, float]) -> 'AnchorVector':
        """Create from anchor name → weight dictionary."""
        weights = np.zeros(6)
        for name, value in d.items():
            idx = ANCHOR_NAMES.index(name.lower())
            weights[idx] = value
        return cls(weights)
    
    @classmethod
    def identity(cls) -> 'AnchorVector':
        """The identity element (origin)."""
        return cls(np.zeros(6))
    
    @classmethod
    def basis(cls, anchor: Anchor, magnitude: float = 1.0) -> 'AnchorVector':
        """Create a basis vector for a single anchor."""
        weights = np.zeros(6)
        weights[anchor.value] = magnitude
        return cls(weights)
    
    def __add__(self, other: 'AnchorVector') -> 'AnchorVector':
        """Vector addition (not the group operation!)."""
        return AnchorVector(self.weights + other.weights)
    
    def __sub__(self, other: 'AnchorVector') -> 'AnchorVector':
        """Vector subtraction."""
        return AnchorVector(self.weights - other.weights)
    
    def __mul__(self, scalar: float) -> 'AnchorVector':
        """Scalar multiplication."""
        return AnchorVector(self.weights * scalar)
    
    def __rmul__(self, scalar: float) -> 'AnchorVector':
        return self.__mul__(scalar)
    
    def norm(self) -> float:
        """Euclidean norm (distance from origin)."""
        return float(np.linalg.norm(self.weights))
    
    def normalize(self) -> 'AnchorVector':
        """Return unit vector in same direction."""
        n = self.norm()
        if n < 1e-10:
            return AnchorVector.identity()
        return AnchorVector(self.weights / n)
    
    def dot(self, other: 'AnchorVector') -> float:
        """Inner product."""
        return float(np.dot(self.weights, other.weights))
    
    def dominant_anchor(self) -> Tuple[Anchor, float]:
        """Return the anchor with highest weight."""
        idx = int(np.argmax(np.abs(self.weights)))
        return Anchor(idx), self.weights[idx]
    
    def to_dict(self) -> Dict[str, float]:
        """Convert to anchor name → weight dictionary."""
        return {name: float(self.weights[i]) for i, name in enumerate(ANCHOR_NAMES)}
    
    def __repr__(self):
        parts = [f"{ANCHOR_NAMES[i]}={self.weights[i]:.3f}" 
                 for i in range(6) if abs(self.weights[i]) > 0.01]
        return f"AnchorVector({', '.join(parts) or 'origin'})"


# =============================================================================
# GROUP ELEMENT (Transformation in Truth Space)
# =============================================================================

@dataclass
class GroupElement:
    """
    An element of the truth group G.
    
    Each group element represents a mathematical transformation that can be
    composed with others. The element is characterized by:
    - position: Where it maps the identity (its anchor vector)
    - name: Human-readable description
    - inverse_name: Name of the inverse transformation
    
    Group Operation:
        g₁ ⊕ g₂ represents applying g₂ first, then g₁
        (function composition order)
    """
    position: AnchorVector
    name: str = ""
    inverse_name: str = ""
    category: str = "general"
    
    # Structure constants for the Lie algebra (simplified)
    # [Xᵢ, Xⱼ] = cᵢⱼₖ Xₖ
    _structure_constants: np.ndarray = field(default=None, repr=False)
    
    def __post_init__(self):
        if self._structure_constants is None:
            # Initialize with approximate structure constants
            # These encode how anchor generators combine
            self._structure_constants = self._compute_structure_constants()
    
    def _compute_structure_constants(self) -> np.ndarray:
        """
        Compute Lie algebra structure constants.
        
        These encode the non-commutativity of the group:
        [Xᵢ, Xⱼ] = Σₖ cᵢⱼₖ Xₖ
        
        For truth space, key relations include:
        - [inverse, pattern] ~ identity (inverse compositions simplify)
        - [unity, pattern] ~ 0 (trig identities commute)
        - [growth, pattern] ~ growth (φ and fractals interact)
        """
        c = np.zeros((6, 6, 6))
        
        # Key non-zero structure constants (antisymmetric in first two indices)
        # [inverse, pattern] → identity (simplification)
        c[2, 4, 0] = 0.5
        c[4, 2, 0] = -0.5
        
        # [growth, pattern] → growth (self-similarity)
        c[5, 4, 5] = 0.3
        c[4, 5, 5] = -0.3
        
        # [inverse, growth] → stability (φ⁻¹ = φ - 1)
        c[2, 5, 1] = 0.4
        c[5, 2, 1] = -0.4
        
        return c
    
    @classmethod
    def identity(cls) -> 'GroupElement':
        """The identity element e."""
        return cls(
            position=AnchorVector.identity(),
            name="identity",
            inverse_name="identity",
            category="identity"
        )
    
    @classmethod
    def from_expression(cls, expr: str) -> 'GroupElement':
        """
        Create a group element from a mathematical expression.
        
        Analyzes the expression to determine its anchor weights.
        """
        position = cls._analyze_expression(expr)
        return cls(
            position=position,
            name=expr,
            inverse_name=cls._infer_inverse(expr),
            category=cls._infer_category(expr)
        )
    
    @staticmethod
    def _analyze_expression(expr: str) -> AnchorVector:
        """Analyze expression to determine anchor weights."""
        weights = np.zeros(6)
        expr_lower = expr.lower()
        
        # Check for purely algebraic expressions first (no special functions)
        has_trig = any(f in expr_lower for f in ['sin', 'cos', 'tan'])
        has_exp = any(f in expr_lower for f in ['exp', 'log', 'e**'])
        has_special = has_trig or has_exp or 'phi' in expr_lower or 'φ' in expr_lower
        
        # Pattern detection for each anchor
        
        # Identity: expressions that simplify to x or 0
        if 'arctan(tan' in expr_lower or 'log(exp' in expr_lower or 'exp(log' in expr_lower:
            weights[0] += 0.4  # identity
            weights[2] += 0.4  # inverse
        
        # Stability: expressions involving 1 or fixed points
        if '= 1' in expr_lower or '**2' in expr_lower or '²' in expr_lower:
            weights[1] += 0.3
        
        # Inverse: inverse function compositions
        if 'arc' in expr_lower or 'log' in expr_lower or '1/' in expr_lower:
            weights[2] += 0.3
        
        # Unity: Pythagorean-type expressions
        if 'sin' in expr_lower and 'cos' in expr_lower:
            weights[3] += 0.4
        if 'sinh' in expr_lower or 'cosh' in expr_lower:
            weights[3] += 0.3
        
        # Pattern: trigonometric, recursive
        if 'sin' in expr_lower or 'cos' in expr_lower or 'tan' in expr_lower:
            weights[4] += 0.3
        if any(f'{n}x' in expr_lower for n in range(2, 8)):
            weights[4] += 0.2  # Multiple angle formulas
        
        # Growth: exponential, golden ratio
        if 'exp' in expr_lower or 'e**' in expr_lower:
            weights[5] += 0.3
        if 'phi' in expr_lower or 'φ' in expr_lower or '1.618' in expr:
            weights[5] += 0.4
        
        # If no special functions detected, it's algebraic
        if not has_special:
            weights[0] += 0.4  # identity (algebraic expressions are close to identity)
            weights[1] += 0.4  # stability (constants, polynomials)
        
        # Normalize
        total = np.sum(weights)
        if total > 0:
            weights /= total
        
        return AnchorVector(weights)
    
    @staticmethod
    def _infer_inverse(expr: str) -> str:
        """Infer the inverse transformation name."""
        inverses = {
            'sin': 'arcsin', 'cos': 'arccos', 'tan': 'arctan',
            'arcsin': 'sin', 'arccos': 'cos', 'arctan': 'tan',
            'exp': 'log', 'log': 'exp',
            'sinh': 'arcsinh', 'cosh': 'arccosh', 'tanh': 'arctanh',
        }
        for func, inv in inverses.items():
            if func in expr.lower():
                return expr.lower().replace(func, inv)
        return f"inverse({expr})"
    
    @staticmethod
    def _infer_category(expr: str) -> str:
        """Infer the mathematical category."""
        expr_lower = expr.lower()
        if any(f in expr_lower for f in ['sin', 'cos', 'tan']):
            if 'h' in expr_lower:  # sinh, cosh, tanh
                return 'hyperbolic'
            return 'trigonometric'
        if any(f in expr_lower for f in ['exp', 'log']):
            return 'exponential'
        if 'phi' in expr_lower or 'φ' in expr_lower:
            return 'golden'
        return 'algebraic'
    
    def compose(self, other: 'GroupElement') -> 'GroupElement':
        """
        Group operation: self ⊕ other.
        
        This represents applying 'other' first, then 'self'.
        Uses Baker-Campbell-Hausdorff formula for Lie groups:
        
        exp(X) · exp(Y) = exp(X + Y + ½[X,Y] + ...)
        """
        # First-order: simple addition
        new_weights = self.position.weights + other.position.weights
        
        # Second-order: Lie bracket correction
        bracket = np.zeros(6)
        for i in range(6):
            for j in range(6):
                for k in range(6):
                    bracket[k] += 0.5 * self._structure_constants[i, j, k] * \
                                  self.position.weights[i] * other.position.weights[j]
        
        new_weights += bracket
        
        return GroupElement(
            position=AnchorVector(new_weights),
            name=f"({self.name} ∘ {other.name})",
            category=self.category if self.category == other.category else "mixed"
        )
    
    def __matmul__(self, other: 'GroupElement') -> 'GroupElement':
        """Use @ operator for group composition."""
        return self.compose(other)
    
    def inverse(self) -> 'GroupElement':
        """
        Compute the group inverse g⁻¹.
        
        For a Lie group element exp(X), the inverse is exp(-X).
        """
        return GroupElement(
            position=AnchorVector(-self.position.weights),
            name=self.inverse_name or f"inverse({self.name})",
            inverse_name=self.name,
            category=self.category
        )
    
    def conjugate(self, by: 'GroupElement') -> 'GroupElement':
        """
        Conjugation: by ⊕ self ⊕ by⁻¹
        
        Conjugation preserves group structure and reveals symmetries.
        Elements in the same conjugacy class are "equivalent" truths.
        """
        return by @ self @ by.inverse()
    
    def commutator(self, other: 'GroupElement') -> 'GroupElement':
        """
        Lie bracket [self, other] = self ⊕ other ⊕ self⁻¹ ⊕ other⁻¹
        
        Measures non-commutativity. If [g, h] = e, then g and h commute.
        """
        return self @ other @ self.inverse() @ other.inverse()
    
    def distance_to(self, other: 'GroupElement') -> float:
        """
        Geodesic distance in the group manifold.
        
        This corresponds to the "proof length" between two truths.
        """
        diff = self.position - other.position
        return diff.norm()
    
    def is_identity(self, tolerance: float = 1e-10) -> bool:
        """Check if this is (approximately) the identity element."""
        return self.position.norm() < tolerance
    
    def __repr__(self):
        return f"GroupElement('{self.name}', {self.position})"


# =============================================================================
# SUBGROUP (Category of Truths)
# =============================================================================

@dataclass
class Subgroup:
    """
    A subgroup of the truth group.
    
    Subgroups correspond to mathematical categories:
    - Trigonometric subgroup: Generated by unity and pattern
    - Exponential subgroup: Generated by inverse and growth
    - Algebraic subgroup: Generated by identity and stability
    """
    name: str
    generators: List[GroupElement]
    elements: List[GroupElement] = field(default_factory=list)
    
    def contains(self, element: GroupElement) -> bool:
        """Check if element is in this subgroup."""
        # Project onto generator subspace
        gen_positions = np.array([g.position.weights for g in self.generators])
        if len(gen_positions) == 0:
            return element.is_identity()
        
        # Check if element is in span of generators
        try:
            coeffs, residual, _, _ = np.linalg.lstsq(gen_positions.T, 
                                                      element.position.weights, 
                                                      rcond=None)
            return np.linalg.norm(residual) < 0.1
        except:
            return False
    
    def generate(self, max_depth: int = 3) -> List[GroupElement]:
        """Generate subgroup elements up to given depth."""
        elements = [GroupElement.identity()]
        frontier = list(self.generators)
        
        for _ in range(max_depth):
            new_frontier = []
            for g in frontier:
                for h in self.generators:
                    composed = g @ h
                    if not any(composed.distance_to(e) < 0.1 for e in elements):
                        elements.append(composed)
                        new_frontier.append(composed)
            frontier = new_frontier
        
        self.elements = elements
        return elements


# =============================================================================
# TRUTH GROUP (The Full Structure)
# =============================================================================

class TruthGroup:
    """
    The complete truth group G.
    
    This is the main interface for group-theoretic operations on truth space.
    
    Structure:
        - 6-dimensional Lie group
        - Non-abelian (transformations don't commute)
        - Connected (any two truths can be linked)
        - Has natural subgroups (mathematical categories)
    
    Usage:
        group = TruthGroup()
        
        # Create elements
        g = group.element("sin²(x) + cos²(x)")
        h = group.element("1")
        
        # Check if they're the same truth (same location)
        if group.are_equivalent(g, h):
            print("Identity found!")
        
        # Find the "proof" (path between truths)
        path = group.geodesic(g, h)
    """
    
    def __init__(self):
        self._setup_generators()
        self._setup_subgroups()
    
    def _setup_generators(self):
        """Set up the 6 Lie algebra generators."""
        self.generators = {}
        for anchor in Anchor:
            self.generators[anchor] = GroupElement(
                position=AnchorVector.basis(anchor),
                name=ANCHOR_NAMES[anchor.value],
                category="generator"
            )
    
    def _setup_subgroups(self):
        """Set up standard subgroups."""
        self.subgroups = {
            'trigonometric': Subgroup(
                name='trigonometric',
                generators=[
                    self.generators[Anchor.UNITY],
                    self.generators[Anchor.PATTERN],
                ]
            ),
            'exponential': Subgroup(
                name='exponential',
                generators=[
                    self.generators[Anchor.INVERSE],
                    self.generators[Anchor.GROWTH],
                ]
            ),
            'algebraic': Subgroup(
                name='algebraic',
                generators=[
                    self.generators[Anchor.IDENTITY],
                    self.generators[Anchor.STABILITY],
                ]
            ),
        }
    
    def identity(self) -> GroupElement:
        """Return the identity element."""
        return GroupElement.identity()
    
    def element(self, expr: str) -> GroupElement:
        """Create a group element from an expression."""
        return GroupElement.from_expression(expr)
    
    def generator(self, anchor: Anchor) -> GroupElement:
        """Get a generator element."""
        return self.generators[anchor]
    
    def are_equivalent(self, g1: GroupElement, g2: GroupElement, 
                       tolerance: float = 0.1) -> bool:
        """
        Check if two elements represent the same truth.
        
        Two elements are equivalent if they map to the same location
        in truth space (within tolerance).
        """
        return g1.distance_to(g2) < tolerance
    
    def geodesic(self, g1: GroupElement, g2: GroupElement, 
                 n_steps: int = 10) -> List[GroupElement]:
        """
        Compute the geodesic (shortest path) between two elements.
        
        This represents the "proof" connecting two truths.
        """
        path = []
        for t in np.linspace(0, 1, n_steps):
            interp_weights = (1 - t) * g1.position.weights + t * g2.position.weights
            path.append(GroupElement(
                position=AnchorVector(interp_weights),
                name=f"path({t:.2f})",
                category="geodesic"
            ))
        return path
    
    def orbit(self, g: GroupElement, generators: List[GroupElement] = None,
              max_depth: int = 3) -> List[GroupElement]:
        """
        Compute the orbit of g under group action.
        
        The orbit is the set of all elements reachable from g by
        applying group generators.
        """
        if generators is None:
            generators = list(self.generators.values())
        
        orbit = [g]
        frontier = [g]
        
        for _ in range(max_depth):
            new_frontier = []
            for elem in frontier:
                for gen in generators:
                    # Apply generator and its inverse
                    for h in [gen, gen.inverse()]:
                        composed = h @ elem
                        if not any(composed.distance_to(o) < 0.1 for o in orbit):
                            orbit.append(composed)
                            new_frontier.append(composed)
            frontier = new_frontier
        
        return orbit
    
    def find_symmetries(self, expr: str) -> List[GroupElement]:
        """
        Find symmetries (fixed points) of an expression.
        
        A symmetry is a group element g such that g(expr) = expr.
        These correspond to mathematical identities.
        """
        g = self.element(expr)
        symmetries = []
        
        # Check each generator
        for anchor, gen in self.generators.items():
            # If conjugation by gen leaves g approximately fixed,
            # gen is a symmetry
            conjugated = g.conjugate(gen)
            if self.are_equivalent(g, conjugated, tolerance=0.05):
                symmetries.append(gen)
        
        return symmetries
    
    def classify(self, g: GroupElement) -> str:
        """Classify an element by its subgroup membership."""
        for name, subgroup in self.subgroups.items():
            if subgroup.contains(g):
                return name
        return "general"
    
    def commutator_table(self) -> np.ndarray:
        """
        Compute the commutator table [Xᵢ, Xⱼ].
        
        This reveals the Lie algebra structure.
        """
        n = len(self.generators)
        table = np.zeros((n, n, n))
        
        gens = list(self.generators.values())
        for i, gi in enumerate(gens):
            for j, gj in enumerate(gens):
                comm = gi.commutator(gj)
                table[i, j, :] = comm.position.weights
        
        return table
    
    def __repr__(self):
        return f"TruthGroup(dim=6, subgroups={list(self.subgroups.keys())})"
